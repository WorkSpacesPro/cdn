
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>bm.md</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        -webkit-box-sizing: border-box;
        -moz-box-sizing: border-box;
        box-sizing: border-box;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        -ms-touch-action: none;
        touch-action: none;
        -webkit-tap-highlight-color: transparent;
      }

      body {
        background: -webkit-linear-gradient(180deg, #e3f2fd 0%, #fff9c4 50%, #ffebee 100%);
        background: -moz-linear-gradient(180deg, #e3f2fd 0%, #fff9c4 50%, #ffebee 100%);
        background: -o-linear-gradient(180deg, #e3f2fd 0%, #fff9c4 50%, #ffebee 100%);
        background: linear-gradient(180deg, #e3f2fd 0%, #fff9c4 50%, #ffebee 100%);
        overflow: hidden;
        font-family: monospace;
      }

      canvas {
        display: block;
      }
    </style>
  </head>

  <body>
    <canvas id="canvas"></canvas>
    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      let mousePosition = { x: 0, y: 0 };
      let isTouching = false;
      let particles = [];
      let textImageData = null;
      let animationFrameId;
      let isInitialAnimation = true;
      let animationStartTime = null;

      function updateCanvasSize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }

      function createTextImage() {
        ctx.fillStyle = "#2C3E50"; // 深蓝灰色，在浅色背景上更清晰
        ctx.save();

        // 根据屏幕宽度动态调整字体大小
        let fontSize;
        if (canvas.width <= 375) {
          fontSize = 80; // 375px及以下屏幕
        } else if (canvas.width <= 480) {
          fontSize = 100; // 小屏手机
        } else if (canvas.width <= 768) {
          fontSize = 140; // 平板和大屏手机
        } else {
          fontSize = 280; // 桌面端
        }

        ctx.font = `900 ${fontSize}px monospace`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        const text = "Ltd.Md";
        const x = canvas.width / 2;
        const y = canvas.height / 2;

        ctx.fillText(text, x, y);
        ctx.restore();

        textImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      function createParticle() {
        if (!textImageData) return null;

        const data = textImageData.data;

        for (let attempt = 0; attempt < 100; attempt++) {
          const x = Math.floor(Math.random() * canvas.width);
          const y = Math.floor(Math.random() * canvas.height);

          if (data[(y * canvas.width + x) * 4 + 3] > 128) {
            return {
              x: Math.random() * canvas.width, // 初始随机位置
              y: Math.random() * canvas.height, // 初始随机位置
              baseX: x,
              baseY: y,
              size: Math.random() * 1.5 + 1,
              // 为星光闪烁增加的参数（相位/速度/幅度）
              twinklePhase: Math.random() * Math.PI * 2,
              twinkleSpeed: 0.5 + Math.random() * 1.5, // Hz 范围内的轻微变化
              twinkleAmplitude: 0.3 + Math.random() * 0.5, // 透明度波动幅度
            };
          }
        }

        return null;
      }

      function createInitialParticles() {
        // 根据屏幕大小调整粒子数量
        let baseParticleCount;
        if (canvas.width <= 375) {
          baseParticleCount = 3000; // 小屏幕减少粒子数量提高性能
        } else if (canvas.width <= 768) {
          baseParticleCount = 5000;
        } else {
          baseParticleCount = 8000;
        }

        const particleCount = Math.floor(
          baseParticleCount *
            Math.sqrt((canvas.width * canvas.height) / (1920 * 1080))
        );
        particles = [];

        for (let i = 0; i < particleCount; i++) {
          const particle = createParticle();
          if (particle) particles.push(particle);
        }

        // 重置动画状态
        isInitialAnimation = true;
        animationStartTime = Date.now();
      }

      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 创建渐变背景
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, "#E3F2FD"); // 浅蓝色
        gradient.addColorStop(0.5, "#FFF9C4"); // 浅黄色
        gradient.addColorStop(1, "#FFEBEE"); // 浅红色
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 当前时间（秒），用于闪烁动画
        const t = performance.now() / 1000;

        const { x: mouseX, y: mouseY } = mousePosition;
        // 根据屏幕大小调整交互距离
        const maxDistance = canvas.width <= 768 ? 150 : 240;

        // 计算初始聚合动画的进度
        let gatherProgress = 1;
        if (isInitialAnimation && animationStartTime) {
          const elapsed = Date.now() - animationStartTime;
          const animationDuration = 2000; // 2秒
          gatherProgress = Math.min(elapsed / animationDuration, 1);

          // 使用二次缓动函数 - 先慢后快 (ease-in)
          gatherProgress = gatherProgress * gatherProgress;

          if (gatherProgress >= 1) {
            isInitialAnimation = false;
          }
        }

        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];
          const dx = mouseX - p.x;
          const dy = mouseY - p.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (
            !isInitialAnimation &&
            distance < maxDistance &&
            (isTouching || !("ontouchstart" in window))
          ) {
            const force = (maxDistance - distance) / maxDistance;
            const angle = Math.atan2(dy, dx);
            const moveX = Math.cos(angle) * force * 60;
            const moveY = Math.sin(angle) * force * 60;
            p.x = p.baseX - moveX;
            p.y = p.baseY - moveY;

            // 交互高亮颜色再加深一档
            ctx.fillStyle = "#FFA726"; // 更深的琥珀橙
          } else {
            // 初始聚合动画或正常回到基础位置
            const targetX = p.baseX;
            const targetY = p.baseY;

            if (isInitialAnimation) {
              // 在聚合动画期间，根据进度从随机位置移动到目标位置
              // 如果这是第一帧，记录初始位置
              if (!p.initialX) {
                p.initialX = p.x;
                p.initialY = p.y;
              }

              p.x = p.initialX + (targetX - p.initialX) * gatherProgress;
              p.y = p.initialY + (targetY - p.initialY) * gatherProgress;
            } else {
              // 正常的回归动画
              p.x += (targetX - p.x) * 0.1;
              p.y += (targetY - p.y) * 0.1;
            }

            // 默认粒子颜色再加深一档
            ctx.fillStyle = "#78909C"; // 更深的蓝灰
          }

          // 星光闪烁：在开场动画结束后生效
          let alpha = 1;
          let sizeScale = 1;
          if (!isInitialAnimation) {
            // 0..1 的平滑闪烁值
            const tw = (1 + Math.sin(p.twinklePhase + t * p.twinkleSpeed * Math.PI * 2)) / 2;
            // 偶发尖峰（像星光一闪），幂次越大越尖锐
            const spike = Math.pow(tw, 8);
            // 透明度在较浅的基础上轻微波动
            alpha = 0.5 + p.twinkleAmplitude * (0.15 + 0.85 * tw); // 大约在 0.5~1 之间
            // 尺寸偶发尖峰带来“闪”的观感
            sizeScale = 1 + 0.6 * spike;
          }

          // 绘制（带透明度与尺寸缩放）
          const drawSize = p.size * sizeScale;
          ctx.globalAlpha = alpha;
          ctx.fillRect(p.x, p.y, drawSize, drawSize);
        }

        // 重置全局透明度，避免影响下一帧背景绘制
        ctx.globalAlpha = 1;

        animationFrameId = requestAnimationFrame(animate);
      }

      function handleResize() {
        updateCanvasSize();
        createTextImage();
        createInitialParticles();
      }

      function handleMove(x, y) {
        mousePosition = { x, y };
      }

      function handleMouseMove(e) {
        handleMove(e.clientX, e.clientY);
      }

      function handleTouchMove(e) {
        if (e.touches.length > 0) {
          e.preventDefault();
          handleMove(e.touches[0].clientX, e.touches[0].clientY);
        }
      }

      function handleTouchStart() {
        isTouching = true;
      }

      function handleTouchEnd() {
        isTouching = false;
        mousePosition = { x: 0, y: 0 };
      }

      function handleMouseLeave() {
        if (!("ontouchstart" in window)) {
          mousePosition = { x: 0, y: 0 };
        }
      }

      // Initialize
      updateCanvasSize();
      createTextImage();
      createInitialParticles();
      animate();

      // Event listeners
      window.addEventListener("resize", handleResize);
      canvas.addEventListener("mousemove", handleMouseMove);
      canvas.addEventListener("touchmove", handleTouchMove, { passive: false });
      canvas.addEventListener("mouseleave", handleMouseLeave);
      canvas.addEventListener("touchstart", handleTouchStart);
      canvas.addEventListener("touchend", handleTouchEnd);
    </script>
  </body>
</html>
